#pragma kernel ExternalForces
#pragma kernel UpdateSpatialHash
#pragma kernel CalculateDensities
#pragma kernel UpdatePositions

// Includes
#include "./FluidMaths2D.hlsl"
#include "./SpatialHash.hlsl"

static const int NumThreads = 64;

// Buffers
RWStructuredBuffer<float2> Positions;
RWStructuredBuffer<float2> PredictedPositions;
RWStructuredBuffer<float2> Velocities;
RWStructuredBuffer<float> Densities;
RWStructuredBuffer<uint3> SpatialIndices; // used for spatial hashing
RWStructuredBuffer<uint> SpatialOffsets; // used for spatial hashing
RWStructuredBuffer<int> lamdas;
RWStructuredBuffer<int> deltaPs;

//Setting
const float gravity;
const uint numParticle;
const float deltaTime;
const float collisionDamping;
const float verticalBoundariesUpper;
const float verticalBoundariesLower;
const float horizontalBoundariesRight;
const float horizontalBoundariesLeft;
const float particleRadius;
const float smoothingRadius;


float2 ExternalForces()
{
	// Gravity
	float2 gravityAccel = float2(0, gravity);

	return gravityAccel;
}

void handleCollision(uint particleIndex)
{
	//Vertical Boundaries
	if(Positions[particleIndex].y - particleRadius < verticalBoundariesLower && Velocities[particleIndex].y < 0)
	{
		Velocities[particleIndex] = float2(Velocities[particleIndex].x, -Velocities[particleIndex].y * collisionDamping);
		Positions[particleIndex] = float2(Positions[particleIndex].x, verticalBoundariesLower);
	}
	if(Positions[particleIndex].y + particleRadius > verticalBoundariesUpper && Velocities[particleIndex].y > 0)
	{
		Velocities[particleIndex] = float2(Velocities[particleIndex].x, -Velocities[particleIndex].y * collisionDamping);
		Positions[particleIndex] = float2(Positions[particleIndex].x, verticalBoundariesUpper);
	}
	//horizontal boundaries
	if(Positions[particleIndex].x - particleRadius < horizontalBoundariesLeft && Velocities[particleIndex].x < 0)
	{
		Velocities[particleIndex] = float2(-Velocities[particleIndex].x * collisionDamping, Velocities[particleIndex].y);
		Positions[particleIndex] = float2(horizontalBoundariesLeft, Positions[particleIndex].y);
	}
	if(Positions[particleIndex].x + particleRadius > horizontalBoundariesRight && Velocities[particleIndex].x > 0)
	{
		Velocities[particleIndex] = float2(-Velocities[particleIndex].x * collisionDamping, Velocities[particleIndex].y);
		Positions[particleIndex] = float2(horizontalBoundariesRight, Positions[particleIndex].y);
	}
}

float CalculateDensity(float2 pos)
{
	int2 originCell = GetCell2D(pos, smoothingRadius);
	float sqrRadius = smoothingRadius * smoothingRadius;
	float density = 0;

	float z;

	// Neighbour search
	for (int i = 0; i < 9; i++)
	{
		uint hash = HashCell2D(originCell + offsets2D[i]);
		uint key = KeyFromHash(hash, numParticle);
		uint currIndex = SpatialOffsets[key];

		while (currIndex < numParticle)
		{
			uint3 indexData = SpatialIndices[currIndex];
			currIndex++;
			// Exit if no longer looking at correct bin
			if (indexData[2] != key) break;
			// Skip if hash does not match
			if (indexData[1] != hash) continue;

			uint neighbourIndex = indexData[0];
			float2 neighbourPos = PredictedPositions[neighbourIndex];
			float2 offsetToNeighbour = neighbourPos - pos;
			float sqrDstToNeighbour = dot(offsetToNeighbour, offsetToNeighbour);

			// Skip if not within radius
			if (sqrDstToNeighbour > sqrRadius) continue;

			// Calculate density and near density
			float dst = sqrt(sqrDstToNeighbour);
			z += SmoothingKernelPoly6(4.0, 5.0);
			density += SmoothingKernelPoly6(dst, smoothingRadius);
		}
	}

	return z;
}

[numthreads(NumThreads,1,1)]
void ExternalForces(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticle) return;

	// External forces (gravity and input interaction)
	Velocities[id.x] += ExternalForces() * deltaTime;

	// Predict
	const float predictionFactor = 1 / 120.0;
	PredictedPositions[id.x] = Positions[id.x] + Velocities[id.x] * predictionFactor;
}

[numthreads(NumThreads,1,1)]
void CalculateDensities (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticle) return;

	float2 pos = PredictedPositions[id.x];
	Densities[id.x] = CalculateDensity(pos);
}

[numthreads(NumThreads,1,1)]
void UpdateSpatialHash (uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticle) return;

	// Reset offsets
	SpatialOffsets[id.x] = numParticle;
	// Update index buffer
	uint index = id.x;
	int2 cell = GetCell2D(PredictedPositions[index], smoothingRadius);
	uint hash = HashCell2D(cell);
	uint key = KeyFromHash(hash, numParticle);
	SpatialIndices[id.x] = uint3(index, hash, key);
}


[numthreads(NumThreads, 1, 1)]
void UpdatePositions(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= numParticle) return;

	Positions[id.x] += Velocities[id.x] * deltaTime;
	handleCollision(id.x);
}